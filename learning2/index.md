# 内部-架构学习整理


架构学习整理 
## 1.当我们在谈架构时，我们谈的是什么？
首先，架构是一个抽象词语，100 个人谈架构可能会有 101种答案

个人看到最简洁的说法就是：架构=构件＋交互。其实它没有一个标准，这里我们不纠结名词概念，
在现代企业里，可根据从业务需求到系统实现的不同需要分为：业务架构、应用架构。数据架构、技术架构。也被称为 TOGAF4A架构

 被普遍定义的四大架构领域

图

- 业务架构：比如前台、中台、后台、基础支撑
- 应用架构：比如商品、 交易、合同、优惠、资金等各个域的应用
- 技术架构：比如高可用、高性能、安全生产B/S、C/S 微服务．分布式
- 数据架构：比如数据存储方式（读写分离、分布式存储、数据的生产与消费方式)
 
今天，我们要谈的是「技术架构」，而且是偏后端的技木架构，前端会稍微带一下

> 注：笔者在后端架构上的经验不算多（来阿里之前做过三年的 NET 开发，但仪限开 wincovs 应用开数据分离架构的设
   计和部署，以及稍微尝试过 memCached lucence 等美机架构的中间件）对二分布式架构的经验是比较少的。此文
   笔者最近在学习架构过程中的一些笔记，并非实战分享，如以下技大论点有错误欢迎红正

### 1.1架构与框架的区别？
框架的英文是 Framework. 架构的英文是 Architecture

框架关注的是"规范”，架构关注的是"结构”

软件框架 (Software framework）通常指的是为了实现某个业界标准或完成特定基本任务的软件组件规范，也指为了实现某个软件组件规范时，提供规范所要求之基础功能的软件产品。
> 问：MVC是架构还是框架？

## 2.架构设计的核心目的
   几个架构设计的误区
- - “因为架构很重要，所以要做架构设计"
- "每个系统都萝做架构设计”
- - 公司流程要求系统开发过程中必须有架构设计”
- "为了高性能、高可用、可扩展，所以要做架构设计"
- - "淘宝的架构是这么做的，我们也要这么做"
- - "微服务现在很流行，我们的架构应该使用微服务架构"
- "架构是需要专门的架构师来做的"

架构设计的主要目的是为了解決软件复杂度带来的问题

###   2.1 复杂度来源：高性能
- 硬件性能：单机性能、集群性能、终端性能
- 网络性能：带宽、地域、稳定
- 算法性能：任务分配、轮训、渲染

性能衡量术语：吞吐量 (TPS)、 QPS、并发数、响应时间 (RT)、秒开率等

### 2.2复杂度来源：高可用
   高可用本质上都是通过“元余"来实现高可用，说白了就是『加机器』
   - 计算高可用：难点在"无中断”的计算服务
   - 存储高可用：难点在：如何规避数据不一致
   - 高可用衡量术语：N个9（可用性 99.9999%）.1-5-10等

思考一不，高可用看起都是后端的东西，这个概念放在前端，我们有哪些需要注意的地方？

###  2.3 复杂度来源：可扩展
- 预测变化
  - 既然是预测，都存在出错的可能性
  - 依赖经验
  - 深入组织、业务
- 应对变化
  - 使用成熟技术 
  - 经验依赖 
  - 面向对象（6 大设计原则） 
  - 设计模式 （GoF 23 设计模式）

### 2.4 复杂度来源：低成本
- 规模扩大-＞需要创新、自研 -＞开源
- 小优化带来大提升

### 2.5 复杂度来源：安全
- 功能安全（防小偷)
  - 比如我们常见的 xSS、 XSRF 攻击
- 架构安全（防强盗）
  - 比如我们常见的 DDoS 攻击
### 2.6 复杂度来源：规模
- 系统规模 
  - 系统模块越来越多，导致复杂度提升
- 人员规模
  - 人员规模的变化，需要协同的分支越来越多
  
这两个因素导致看不懂、改不动、不敢改、 修不了的困境

## 3. 架构原则
### 3.1 合适原则
   业界领先的方案其实都是"逼"出来的！不要一开始就要造一座罗马帝国。军记一个原则：「合适优于领先」
   - 合适当下和可预测的业务情况
   - 合适当下团队规模
   - 合适当下技术成熱情况

### 3.2简单原则
- 组件越多，就越有可能其中某个组件出现故障，从而导致系统故障
- “复杂”在制造领域代 表先进，在建筑领域代表领先，但在软件领域，却恰恰相反，代表的是“问题”。

### 3.3 可演进原则
- 演进是指架构上的一些变化，比如当业务发生变化时，架构要扩展、重构，甚至重写；
- 代码也许会重写，但有价值的经验、教训、逻辑、设计等（类似生物体内的基因）却可以在新架构中延续。

### 3.4 可持续原则
演进是指架构上的一些变化，而持续性针对的是开发人员的变化
- 敢于修正架构中的错误部分
- 技能水平的持续改进
- 应用的持续改进
- 设计能力的持续提升
- 人员变化带来的持续投入风险控制等
  
## 4.识别复杂度和优先级
  构建复杂度的来源清单
  一高性能、可用性、扩展性、安全、低成本、规模等。
  - 结合需求、技术、团队、资源等对上述复杂度逐一分析是否需要？是否关键？
  -  从功能需求的未来变更幅度等方面去考虑架构的扩展性，延续性。
  - 按照上述的分析结论，得到复杂度按照优先级的排序清单，越是排在前面的复杂度，就越关键，就越优先解决。
## 5. 评估和设计备选方案
   - 业务变化：如一旦业务发生不可预知的变化，比如架构调整，方向调整，需求调整，如何应对？
   - 人员变化：如一旦人员发声变动、裁员、架构如何正常演化？
   - 三方因素：如开源框架不可用之后，用什么方案替代？
## 6. 解决业务复杂度的三种架构模式
   高性能、高可用、可扩展
###   6.1 高性能架构模式
####   6.1.1高性能之读写分离
   - 考虑复制延迟
   - 考虑分配机制
####   6.1.2 高性能之负载均衡
   -  DNS 负载均衡
   -  F5 硬件负载均衡
   - Nginx 反向代理
#### 6.1.3高性能之分库分表
   - 业务分库
     {{< figure src="/image/tech/al/业务分库-1.png" title="" >}}
   - 分表
    {{< figure src="/image/tech/al/分表-1.png" title="水平/垂直拆分" >}}

####      6.1.4 高性能之缓存

 将可能重复使用的数据放到内存中， 一次生成、多次使用，避免每次使用都去访问存储系统，技术典型代表：Memcache、Redis 和Tair。要考虑以下几点：

 - 失效：应用程序先从cache取数据，没有得到，则从数据 库中取数据，成功店，放到缀存中
 - 命中：应用程序从cache中取数据．取到后返回
 - 更新：先把数据存到数据库中，成功后．再让缓存失效
 - 缓存穿透问题，未命中考虑采用多级缓存
 - 分级缓存，比如粉丝100W以上的明星缓存 100份
 - 缓存雪崩，性能急剧下降是否会有风险
####      6.1.5 高性能之 Nosql
 是关系型数据库的一个补充
 - K-V存储：解决关系数据库无法存储数据结构的问题，以 Redis 为代表。
 - 文档数据库：解决关系数据库强 schema 约束的问题，以 MongoDB 为代表。
 - 列式数据库：解决关系数据库大数据场景下的 V0 问题，以 HBase 为代表。
 - 全文搜索引擎：解决关系数据库的全文搜索性能问题，以 Elastiasearch 为代表。

###     6.2 高可用架构模式
 CAP 原理：在一个分布式系统(指互相连接并共享数据的节点的集合）中，当涉及读写操作时，只能保证一致性
 (Consistence）、可用性 (Availability)、分区容错性 (Partition Tolerance）三者中的两个，另外一个必须被牺牲。这也
 是我们做架构升级为什么一定要停机的核心原因。

{{< figure src="/image/tech/al/CAP-2.png" title="CAP" >}}
{{< figure src="/image/tech/al/CAP-1.png" title="CAP" >}}

- 一致性（Consistency） 对于客户端的每次读操作，要么读到的是最新的数据，要么读取失败。换句话说，一致性是站在分布式系统的角度，对访问本系统的客户端的一种承诺：要么我给您返回一个错误，要么我给你返回绝对一致的最新数据，不难看出，其强调的是数据正确。

- 可用性（Availability） 任何客户端的请求都能得到响应数据，不会出现响应错误。换句话说，可用性是站在分布式系统的角度，对访问本系统的客户的另一种承诺：我一定会给您返回数据，不会给你返回错误，但不保证数据最新，强调的是不出错。

- 分区容错性（Partition tolerance）由于分布式系统通过网络进行通信，网络是不可靠的。当任意数量的消息丢失或延迟到达时，系统仍会继续提供服务，不会挂掉。换句话说，分区容忍性是站在分布式系统的角度，对访问本系统的客户端的再一种承诺：我会一直运行，不管我的内部出现何种数据同步问题，强调的是不挂掉。
  
  - 容错性：网络通信肯定有失败的可能
  - 一致性：一旦通信失败，一致性就无法保证
  。可用性：要保证一致性，就要牺牲某个区域的可用性

高可用架构的 FMEA 方法论 (Failure Mode and Effects Analysis, 故障模式与影响分析)：
1. 给出初始的架构设计图
2．假设架构中某个部件发生故障
3. 分析此故障对系统功能造成的影响
4. 根据分析结果，判断架构是否需要进行优化
####         6.2.1高可用之计算
- 主备
   - 冷备：备机不启动
   - 温备、备机启动但不提供服务
- 主从 
   - 从机负责部分计算，需要任务分配器
- 集群
  - 对称集群，每个集群是一个完整的计算单元
  - 非对称集群，每个集群的角色不同，需要更复杂的任务分配机制
  
还记得 ACP 认证时候的频繁出现的「弹性伸缩 (Auto Scaling)』吗?

####      6.2.2高可用之存储
- 双机架构（就是两台机器）
  - 主备复制 
  - 主从复制 
  - 主备/主从双机切换 
  - 主主
- 数据集群（多台机器组成的其中一个业务单元，我们也叫单元化)

多台机器组合在一起形成一个统一的系统
- 数据集中集群，理解为1主多备或者1主多从，需要考虑每个主机状态检测，如何分配。技术代表 ZooKeeper
- 数据分散集群，每台服务器都是其中一员，负责读写，需要有一个角色来负责执行数据分配算法，技术代表
Hadoop.Hbase

- 数据分区（我们也叫地域和可用区）
将数据按照一定的规则进行分区，不同分区分布在不同的地理位置上
  - 集中式，找同一个备胎
  - 互备式，相互做备胎
  - 独立式、各找各备胎
  > 思考一下，计算高可用与存储高可用的异同？
####       6.2.3 高可用之异地多活（我们也叫单元化部署）
  类似于"不要把鸡蛋都放在同一篮子里”；多活就是指不同地理位置上的系统都能够提供业务服务，这里的"活〞是活动、活跃
  的意思。
- 标准
  - 正常情况下，用户无论访问哪一个地点的业务系统，都能够得到正确的业务服务
  - 某个地方业务异常的时候，用户访问其他地方正常的业务系统，能够得到正确的业务服务。
- 代价
  - 系统复杂度会发生质的变化，需要设计复杂的异地多活架构
  - 成本会上升，毕竟要多在一个或者多个机房搭建独立的一套业务系统。
  
异地多活的类型
- 同城异区
- 跨城异地
- 跨国异地
  {{< figure src="/image/tech/al/交易平台异地多活系统架构-1.png" title="" >}}

### 6.3 可扩展架构模式
可扩展架构基本思想：拆＋编排！
- 面向流程拆分和编排：将整个业务流程拆分为几个阶段，每个阶段作为一部分。比如：分层架构．流程编排
- 面向服务拆分和编排：将系統提供的服务拆分，每个服务作为一部分。比如：SOA．微服务、服务编排
- 面向功能拆分和编排：将系统提供的功能拆分，每个功能作为一部分。比如：微内核架构、规则编排
#### 6.3.1 (Layered Architecture)
- 开放接口层：可直接封装 Service 方法暴露成 RPC 接口；通过 web封装成http 接口;进行 网关安全控制、流量控制等
- 终端显示层：各个端的模板渲染并执行显示的层。当前主要是 Velocity 渲染，JS 渲染，JSP 渲染，移动端展示等
- web层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等
- Service 层：相对具体的业务逻辑服务层
- Manager 层：通用业务处理层
  - 1）对第三方平台封装的层，预处理返回结果及转化异常信息；
  - 2）对Service 层通用能力的下沉，如缓存方案、中间件通用处理;
  - 3)与DAO层交互，对多个DAO的组合复用
- DAO层：数据访问层，与底层 My SQL、Oracle、Hbase 进行数据交互
- 外部接口或第三方平台：包括其它部门 RPC 开放接口，基础平台，其它公司的 HTTP 接口

{{< figure src="/image/tech/al/系统分层规范-1.png" title="" >}}

#### 6.3.2 微内核架构 (microkernel architecture)
内核 (core）通常只包含系统运行的最小功能。插件则是互相独立的，插件之问的通信，应该减少到最低，避免出现互相依赖的问题。

我们常见的采用微内核架构的有
-  Vue
-  JQuery
-  ernt
-  Babel
-  WebPack

#### 6.3.3 SOA (microservices architecture)
把系统按照实际业务，拆分成刚刚好大小的，合适的、独立部署的模块，每个模块之间相互独立。模块之问是松轉合的。

{{< figure src="/image/tech/al/SOA.png" title="" >}}

#### 6.3.4 微服务
- SOA 思想的一种实现
- 更细粒度的 SOA
- 微服务是去掉 ESB 后的 SOA
- 去中心化（ESB） 的服务架构
- 微服务的弊端：本质上就是服务的一种分布式部署，增加了协同、联调、调用链路的成本
> 微服务的服务发现与注册中心与 ESB 的区别2

#### 6.3.5 管道架构 (Pipeline Architecture)
管道就像生产流水线上的传送带，过滤器就像每一道工序上的机器。管道负 责数据的传递，原始数据通过管道传送给第一个
过滤器，第一个过滤器处理完成之后，再通过管道把处理结果传送给下一个过滤器，重复这个过程直到处理结束，最终得到
需要的结果数据
我们常见的来用管道架构的有：
-  KOA
-  Dawn
-  Gulp
## 7.架构产出物有哪些？
- 架构图（必须）
- 迭代计划（必须）
- 技术栈&选型（必须）
- 示例代码
- 部署策略
- 测试策路
- 分工人员（必须）

- 附架构评审模板

## 8.淘宝架构演化案例
部分摘自《淘宝技术这十年》
- 03年．买来的电商网站（美国的个人网站 LAMP PHPAuction),一个月上线，`简单原则`
- 03年底，Mysal 撑不住，买 Oracle `合适原则`
- 04年开始，PHP 热切换到 Java，开启一系列架构升级`演化原则、高性能合适原则`
  - member1.taobao.com的故事
  - MVC框架 struts1.x 多人协作很弱，自研webx（—指）
  - 系统划分越来越多，自研分布式 RPC 服务框架，自研 HSF（小邪）
  - 分库分表查询的麻烦，自研DBRoute（行癫）到现在的TDDL
  - Apache 性能扛不住，发起 Tengine（叔度)
  - 商品图片越来越多，自研TFS (Taobao File System)
  - 商品信息和用户信息的膨胜，自创的Key-Value缓存系统一Tair（合井自多隆的TDBM、TBStore )
  - 搭建 CDN（正明）
  - 淘宝旺旺 （直接采用 B2B 贸易通)
- 07年开始，国内第一个前端团队 `高性能`
  - 前后端分离
  - YUI
  - 自研前段框架(TBra, Kissy)
  - TMS、斑马
  -all in (H5€, Weex, Rax. Kraken)
- 08-09年五彩石项目将一个单一的电商系统拆分成商品、交易、会员等各个中心，沉淀出共享中心 `高可用高性能`
- 09年开始，去 IOE (IBM、Oracel、 EMC) `演化原则降成本、创新`
- 15 年中台架构提出，18 年星环发布（业务架构） `规模化成本`
- 18年 一路向北 `演化原则、规模化成本`
- 19 年，核心系统上云，和客户在同一架飞机上

## 9. 来看看我们接触过的前端一些架构
   - 组件化架构
   - 多页应用架构
   - 单页应用架构
   前后端分离架构
   - 微前端架构（南天门、费用中心)
   - 微内核 (BuvCore)
   - 4RR% (CommonBuy. CPQ)
   - Hybrid App 架构（阿里云 App、淘宝、支付宝、钉钉)
   - PWA Web 应用架构
   - 跨端渲染架构(Weex、小程序)

回顾我们的两个架构改造
- 一路向北 `高可用高性能`
- 单元化部署 `高可用`
> 思考：为什么要一路向北，以及一路向北的挑战有哪业？

## 10. 技术架构的下一站一 云原生
学习中，下回分解！

{{< figure src="/image/tech/al/中间件大全.png" title="" >}}
